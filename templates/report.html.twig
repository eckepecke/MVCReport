{% extends "base.html.twig" %}
{% block title %}Magic number{% endblock %}

{% block body %}
    <h1>Rapporter</h1>

    <div class="two-col-wrapper">
        <aside class="aside-left">
            <h2>Innehåll</h4>
            
            <ul>
            <li class="links"><a href="#kmom01">kmom01</a></li>
            <li class="links"><a href="#kmom02">kmom02</a></li>
            <li class="links"><a href="#kmom03">kmom03</a></li>
            <li class="links"><a href="#kmom04">kmom04</a></li>
            <li class="links"><a href="#kmom05">kmom05</a></li>
            <li class="links"><a href="#kmom06">kmom06</a></li>
            <li class="links"><a href="#kmom07">kmom07</a></li>
            </ul>
        </aside>

        <aside class="aside-right">
        <section class="doc">
            <h2 id="kmom01">Kmom01</h2>
            <p>Den enda objektorienteradeprogrammering jag gjort innan denna kursen är oopythonkursen. Konceptet nämndes kort i js-kursen men jag förstod det inte alls då.</p>

<p>Klasser är en samling av kod som hör ihop. Klasser används för att organisera och strukturera kod på ett logiskt sätt och möjliggör återanvändning av kod genom att skapa flera objekt med samma egenskaper och metoder. Objekt är alltså instanser av en klass. På så vis kan vi ha flera objekt med samma metoder men olika attribut (attributen kan också vara samma).</p>  <p>Oftast kommer klasserna ha en konstruktor. Man kan också ha en dekonstruktor om man vill. Har din klass attribut ska du skriva setter- och gettermetoder för att ändra eller hämta egneskapen/attributet.</p>

<p>Kodbasen liknar egentligen mycket av de vi gjort tidigare under programmet. Jag tycker detta ramverk och stukturen känns snäppet krångligare än de vi gjort tidigare. Men jag gissar att i slutet av kursen kommer man känna sig hemma i strukturen. Jag ville byta namn på en controller och det tog ett tag innan jag förstod att filen och klassen måste ha samma namn.</p>

<p>Jag har inte läst hela artikeln då mycket är relaterat till specifika verktyg men något jag fann väldigt hjälpsamt var sektionen om Namespaces. Artikeln gave en kort, enkel förklaring till vad det innebär. Dessutom finns en länk som beskriver noggrannare hur man bör använda namespaces om man jobbar med en autoloader. Kommer säkerligen komma till nytta i denna kursen.</p>

<p>I detta kursmoment har jag lärt mig hur jag installerar Symfony för att kunna skapa en webbplats. Skulle jag göra ett hobbyprojekt nu skulle jag förmodligen välja Symfony för uppgiften. Ramverket känns gediget, jag kan använda html, css, js, och php. Jag får snygga tydliga felmeddelanden när något är fel. Mycket trevligt.</p>
        </section>

        <section class="doc">
            <h2 id="kmom02">Kmom02</h2>
            <p>Komposition är en konstruktion där ett objekt består av ett eller flera andra objekt. En korthand har kort. En kortlek har kort. En bil har en motor, växelspak och backspegel. De är alla exempel på komposition.</p>

<p>Interface används för att göra kod skalbar, modulär, förutsägbar. Interface tvingar alla klasser som implementerar det att innehålla vissa metoder, utan att beskriva hur de ska implementeras. På så vis kan utvecklare jobba på sin egen kod och veta att kollegan kommer skriva någon slags kod som returnerar det han behöver i sin del av koden.</p>  <p>Trait är ett alternativ till arv. Trait gör att man kan återanvända kod utan att behöva ärva. En klass kan implementera flera traits, passar inte ”single-inheritance” i koden så kan traits vara det du behöver</p>

<p>Jag tycker detta kursmomentet var väldigt givande. När jag gjorde övningen för klasserna kändes det lite överväldigande men det var väldigt bra träning för uppgiften. Jag har löst uppgiften i princip som pig game löstes i övningen. Jag har inte implementerat Interface, förmodligen för att jag inte känner mig bekväm med det ännu. Jag vet inte om min lösning är den mest skalbara eller bästa lösningen men jag förstår den i alla fall. Känner jag att jag behöver implementera traits eller interface borde ju kunna åtgärda det i ett senare skede.</p>  <p>Jag har en CardGraphic-klass som ärver från basklassen Card. Jag vet inte vad som väntar i kommande kursmoment men i och med enkelheten kan den med fördel användas som basklass i andra implementationer. Kanska skapas fler klasser i framtiden som ärver av denna enkla Card-klass. CardGraphic har ett nytt attribut och nya metoder för att underlätta den grafiska representationen. CardGraphic initieras konstruktion för DeckOfCards, därför vill jag kalla den relationen komposition. Korten finns inte om DeckOfCards inte finns. Rätta mig om jag har fel men jag vill också kalla relationen mellan CardGraphic och CardHand komposition. Korten läggs till i handklassen och blir en del av handklassens attribut. Känns väldigt mänskligt att kalla det komposition.</p>

<p>Förra veckan hyllade jag Symfony, det var innan jag publicerade till studentservern. Har man mer erfarenhet av ramverk är det kanske inga problem att lista ut varför något inte fungerar. För mig gick mycket tid till att få min kod att fungera på studentservern trots att den redan fungerade felfritt lokalt. Kanske är det en del av webbprogrammerarens vardag man helt enkelt får acceptera.</p>

<p>Min TIL i detta kursmoment är att mycket av programmering handlar om att bygga rätt från grunden. Än så länge har jag bara skrapat ytan på objektorienterad-programmering. Interface verkar vara en stor grej i php. Jag förstår grunderna i varför man vill använda det och jag hoppas i framtiden kunna ha djupare tankar om varför jag vill implementera en viss lösning och inte en annan.</p>
        </section>

        <section class="doc">
            <h2 id="kmom03">Kmom03</h2>
            <p>Jag tycker absolut att flödesdiagrammet och pseudokoden var bra verktyg. Det kanske låter dumt när min kod ser annorlunda ut från det jag planerade innan jag satte igång. Jag följde dock mina flödesdiagramm och pseudokod och hade ett fungerande spel lokalt som i princip var det pseudokoden och flödesdiagrammet planerade. Problemet var att min kontroller blev otroligt tjock då planeringen jag gjorde krävde väldigt många routes och templates. Man kan säga att flödesschemat och pseudo-koden tog mig dit jag siktade, men jag hade siktat otroligt dåligt. Därför började jag om och har nu en mycket mer nedskalad kontroller. Min play()-funktion i spelklassen hanterar alla scenarior nu istället för som tidigare där jag hade olika funktioner som hanterade olika gator i spelet. Mina funktioner som används i spelet hanterar alla gator i spelet vilket gör det lättare att felsöka nu, då felet som uppstår inte kan finnas på så många olika ställen.</p>

<p>Trots att jag förbättrat min initiala kod avsevärt är jag fortfarande lite osäker på mitt projekt. Jag har många klasser som injiceras i spelklassen. Det jag inte kunde förutse på förhand var hur mycket funktioner som skulle behövas för att få alla klasserna att kunna samverka. Istället för att ha 25 funktioner i spelklassen valde jag till slut att använda traits. Det blev en smidig lösning för mig då jag inte behövde skriva en ’Manager’-klass och ha getter funktioner för alla attribut i spelklassen. Men filosofiskt känns det fel att använda traits på det här sättet. Mina traits är helt specifika till min spel-klass, det finns ingen annan klass i hela världen som skulle ha nytta av dom. På något sätt skulle jag vilja ha en manager-klass som också injiceras i spelklassen. Jag kan lätt hitta det jag ska i mina traits då jag är van att använda pokertermer och har själv skrivit koden. Problemet blir då att jag måsta ha getter-funktioner för alla attributen i spelklassen eller så måste jag injicera alla relevanta objekt i mina managers. I och med att mycket av det som mina managers gör är att ändra ”state” eller attribut på spelklasssen valde jag den enkla vägen och använde traits då de har tillgång till attributen i spelklassen. Jag förstår att det är svårt i och med mycket rättningar men skulle hemskt gärna få feedback på hur just denna delen hade kunnat varit bättre. </p>

<p>Jag undrar också över vad jag ska prioritera när det kommer till kontrollern och template-filerna. Jag har nu skalat kontrollern så mycket det går och all logik sker i spelklassen. Validatorerna klara på för hög komplexitet i play()-funktionen man jag vill inte lyfta ut fler delar.  I min mening skulle det leda till fler frågor om jag klumpar ihop vissa spelevents och kallar det ”bothPlayerActions()” eller liknande. Jag hade tidigare 3 eller 4 olika templates och 4 olika routes som hanterade logiken bakom användarens beslut. Call hade en route, bet hade en route, osv. Naturligtvis blev kontrollern enorm. Jag försökte lyfta ut logiken men i och med att jag renderade olika templates och skickade vidare flödet med redirects var mycket tvunget att ske i kontrollern. Jag valde nu att ha bara en template och en route som tar input, uppdaterar spelet och renderar samma template. Jag får då mer kod i template-filen och det ser lite rörigt ut. Jag vet inte riktigt vad min fråga är men jag hoppas på en rak, hård och ärlig analys av mitt projekt.</p>   <p>Att koda i Symfony har varit trevligt nu när jag fått ordning på allt krångel som uppstod i tidigare kursmoment. Jag skulle gärna försöka mig på att använda javascript för att få spelupplevelsen till en högre nivå. Just nu känns allt lite kantigt då motståndaren spelar blixtsnabbt och korten och chipsen flyger utan att man hinner blinka. Foldar motståndaren mot användarens bet kan nog användaren undra vad som hände, var tog min hand vägen? Vann jag potten? Men tiden finns inte just nu att lösa de sakerna.</p>

<p>Min TIL för detta kursmoment är att bygga stora projekt är svårt och mycket tid bör läggas på att bygga de enkla delarna väldigt noga så att när koden växer uppstår så lite problem som möjligt. Ett stort misstag jag gjorde var att bli upphetsad över att skriva en smart motspelare. Jag ville bara bli klar med spellogiken så att jag kunde börja göra motspelaren smart. Jag har spelat poker professionellt i 8 år och tyckte det var väldigt spännande att tänka på hur jag skulle skriva den koden. Nu sitter jag här, en vecka sen och motspelar-klassen har ingen intelligens.</p>
        </section>

        <section class="doc">
            <h2 id="kmom04">Kmom04</h2>
            <p>Till en början tyckte jag att skriva testerna var roligt. Det blir lite repetitivt till slut och man får vara disciplinerad för att inte skriva tester bara för att få mer kodtäckning, utan att faktiskt skriva tester som testar koden väl.  Det är nog roligare att testa andras kod, då man inte själv behöver laga den.</p>

<p>Jag tycker att efter förutsättningarna lyckades jag okej med kodtäckningen. De delar som inte täcks är framförallt motspelarens strategimodul och motspelarens respons till användarens bet. Strategimodulen är något jag skulle vilja skriva om helt och hållet när jag får tiden till det. Just nu har motspelaren en strategi som varken baseras på sina kort, korten på bordet, vilket stackdjup han har etc. I och med att strategin är något av en quick fix som bara returnerar slumpvalda beslut är jag inte särskilt intresserad av att testa den. Motspelarens beslut mot användarens bet skulle dock vara bra att testa. Även om jag lyckades med mockning i andra delar av koden blir det helt enkelt för komplicerat för mig i den här delen av koden. Konceptet med testdriven utveckling tilltalar mig och jag skulle hellre skriva om koden efter att ha skrivit testerna först, istället för att skriva extremt komplicerad testkod. I och med att spelflödet sker i princip en enda lång loop är jag nöjd med att ta mig över 80%. Alla klasserna som agerar byggstenar i spelet är vältestade och fungerar väl. Problemet är spelklassen och dess traits.</p>  <p>I kmom03 fick jag stora problem då jag byggde ett stort komplicerat spel och fick lära mig den hårda vägen att en bra struktur är viktigt. Självklart ser jag nu att hade jag gått in i projektet med en struktur som baserades på testning hade jag snabbare löst vissa delar av spelet som i själva kodandet var svårt att åtgärda då flödet var långt och rörigt. Med testbar kod kan jag testa små delar av koden och se vart felet ligger.</p>

<p>Min TIL för detta kursmoment är att testdriven utveckling kanske är något jag bör pröva och se om det sparar mig tid och möda i mitt kodande.</p> 
        </section>

        <section class="doc">
            <h2 id="kmom05">Kmom05</h2>
            <p><p>Övningen med Symfony och Doctrine gick bra. Jag fick problem med migrationerna när jag gick tillbaka från Mariadb till Sqlite. Jag raderade till slut mina entiteter och migrationer och började om på nytt. Då fungerade allt som jag tänkte igen. Jag blev förvånad över hur enkelt det var att generera alla klasser och att man fick en del grundläggande sql frågor inbyggda i repositoryn.</p>

<p>Jag började med att göra en enkel landningssida som länkade till [CREATE] då jag behövde böcker i min tabell. När jag gjort ett formulär skapade jag också en länk till [READ MANY]. Det kändes naturligt att på den sidan låta användaren klicka på böckerna för att ta sig till [READ ONE]. Där hittar man funktionaliteten för [UPDATE] och [DELETE]. Skulle biblioteket växa kanske man behöver en tabell utan bilder eller en sökfunktion. För nu tycker jag att den här lösningen är snygg och användarvänlig. Jag har lagt till navigeringsknappar som gör att man kan bläddra till nästa eller föregående bok. Funktionalitet förstörs inte om man tar bort eller lägger till böcker. Mina formulär visar med färg vilka fält som är obligatoriska och inte. Om man vill uppdatera en bok fylls nuvarande värden i automatiskt så att man vet vad man behöver lägga till eller ändra på.</p>  <p>De frågor jag ställer mot databasen i detta kursmoment är relativt simpla. Jag hade inga större problem att skriva mina frågor ”utan sql” men framtiden får utvisa vad jag tycker när jag behöver bygga upp mer avancerade frågor. Jag var lite orolig över just denna delen när kursmomentet startade men det var förvånansvärt lätt att hantera. Jag tror att detta kändes obehagligt då jag har jobbat med SQL i databaskursen och jag vet hur jag skriver dessa frågor, men egentligen är ORM det enkla sättet att jobba mot databaser.</p>

<p>Min TIL är att det finns flera anledningar till varför man vill jobba med ORM. Att inte knyta sig till en databasleverantör är den mest uppenbara fördelen. Att kunna fortsätta koda objekorienterat kan göra koden lättare att underhålla och man slipper skriva SQL-kod om man tycker det är jobbigt.</p> </p>
        </section>

        <section class="doc">
            <h2 id="kmom06">Kmom06</h2>
<p>Det jag gillade mest med PhpMetrics var att det var så enkelt att peka ut stora problem i koden. Dels fick jag en översikt på hur komplexa mina klasser är överlag. När det finns klasser som som ligger högt över snittet kan man enkelt identifiera det och försöka åtgärda det. Jag tycker också det var fint att det fanns många olika typer av komplexitet att analysera. Gjorde jag ett bra jobb som minskade komplexiteten på klassen och komplexiteten för systemet ökade?</p>

<p>Scrutinizer var mitt favorit verktyg. Jag förstod från issues att ett jätteproblem i min applikation var hur jag använde mig av traits i spelklassen. Hade jag valt ett mindre spel som 21 hade jag sannolikt kunnat strukturera om hela spelet i en rimlig tidsram. I och med att jag tog mig vatten överhuvudet och valdet ett avancerat pokerspel nöjde jag mig med att förstå att det upplägget med traits var fel beslut. Jag bad om feedback på detta i kmom03 men fick inget svar då. Nu fick jag svart på vitt att det var fel. Trots det fick jag bättre betyg från scrutinizer än jag förväntade mig. Första bygget gav 9.87 och sista 9.95. Jag var uppe på 9.97 ett tag. Sedan ändrade jag lite i strukturen och föll tillbaka. Personligen tyckte jag koden blev mer testbar och lättläst för en människa och behöll således ändringen.</p>

<p>Jag upprepar mig igen här från Metricsrapporten. Jag vill se på kodkvalitet som jag ser på spelteori. Vi kan ta schack som exempel. Öppningen av spelet är extremt viktigt, ifall du lyckas öppna matchen med få misstag, har du kanske råd med en blunder senare i spelet. Om du istället öppnar med många misstag så kan du spela perfekt(utan misstag, i schack och poker är det bästa beslutet ”det minsta misstaget”.) andra halvan och fortfarande förlora, även om din motspelare inte är särskilt duktig. Därför tycker jag det är helt fantastiskt att alla dessa verktyg finns. Jag, en total nybörjare kan skriva kod, få feedback, rätta till min kod och sedan med säkerhet säga att min kod är inte dålig, därför är den bra! Nu är min kod inte speciellt imponerande i och med att enorma misstag begicks innan tillgången till verktygen, men upp till bevis i projektet.</p>  <p>Det finns mjukvara för poker som på ett liknande sätt pekar ut dina misstag och hur stora dom är. Dessa program kostar 10-tusentals kronor för de bra versionerna. Alternativt 200 dollar i månaden. Jag vill verkligen understryka att jag nästan faller av stolen när jag ser att det finns program som lär mig skriva bra kod, aktivt ger mig personlig feedback på det jag gör, och jag betalar inte en krona! Det jag tar med mig från detta kursmoment är en verktygslåda för att bygga bättre applikationer och skriva robust kod.</p>

        </section>

        <section class="doc">
            <h2 id="kmom07">Kmom07-10</h2>
            <h3>Grundkrav</h3>
            <p>Jag valde att göra ett pokerspel för mitt examinerande projekt. Jag tycker kortspel är väldigt roligt och i och med att jag gjorde ett pokerspel tidigare i kursen kändes det naturligt att fortsätta på samma spår men försöka implementera spelet för 3 spelare. Som alltid tycker jag det är svårt att föutskåda hur mycket jobb som väntar i ett projekt. Jag tyckte att jag har koll på pokerregler och trots att jag förstod att det var ett utmanande projekt så var jag positiv och taggad på att sätta igång.
            </p>
            <p>I slutändan tog det avsevärt mycket längre tid att implementera spelet än väntat. Jag  anser att det var ett misstag att välja ett så komplicerat spel då jag lagt minst 100 timmar på projektet och trots det inte hunnit jobba mot alla optionella krav. När kodbasen växer så växer antalet tester jag måste skriva, antalet felmeddelande från diverse verktyg blir fler och jag har behövt kompromissa för att kunna lämna in projektet. När man ensam jobbar på ett så stort projekt kommer man på diverse funktionalitet som borde finnas, pokerregler som ännu inte implementerats eller har implementerats, men på fel sätt. Upptäcker man ett sådant fel sent i processen måste massvis av kod skrivas om, vilket gör att massvis av testkod måste skrivas om och ny logik måste skrivas.
            </p>
            <p>Trots det är jag stolt att spelet fungerar såpass väl som det gör. Flödet utgår från användarens input. Jag ville bygga ett spel som känns som en riktig pokersida. Detta gör flödet mer komplext men applikationen har en trevligare användarupplevelse i min mening. Jag har ändrat utseendet på min webbplats för att skapa en casino-känsla. Jag har försökt skapa ett pokerbord som får plats även på en mindre laptop-skärm.
            </p>
            <p>Spelet har 3 spelare. 1 spelare är användaren, 2 spelare är datorspelare. Den ena datorspelaren har en helt slumpmässig strategi. Spelaren gör inga nybörjarmisstag som att folda när checka är gratis men spelaren tar heller inga beslut beroende på sin handstyrka. Det gör den ”smarta spelaren”. Spelat går ut på att användaren ska gå från en liten summa pengar till en stor summa pengar, och det måste ske snabbt för att användaren ska vinna spelet. Den smarta datorspelaren spelar väldigt aggressivt när han eller hon har en stark hand. Detta gör det svårt för användaren då den initiala stacken är så liten.
            </p>
            <p>
Jag har jobbat hårt med enhetstestningen och phpmetrics. Jag vill understryka att jag utelämnat en del enkla testar på spelklassen då det automatiskt skulle ge mig 95% kodtäckning. Jag har istället fokuserat på att testa klasserna som finns i spelet. I phpmetrics har jag gjort mitt bästa för att hålla nere komplexiteten. Men med stora klasser som gör handjämförelser är det svårt att hålla nere den. Jag ser att ju mer tid jag lägger på att dela upp klasser och kommentera koden så förbättras mina värden. Det är mycket en tidsfråga och jag har som sagt fått prioritera.            </p>
            <h3>API</h3>
            <p>Mitt Json-API visar upp lika delar av statusen på spelet. Här är vad man kan göra med mitt API:
            </p>
            <ul>
                <li>Få all data om ställningen i spelet.</li>
                <li>Få utvald data om användarens status i spelet.</li>
                <li>Tjuvkika på motståndarnas kort.</li>
                <li>Se hur många händer som återstår och hur mycket mer pengar användaren behöver samla för att vinna spelet.</li>
                <li>Byta namn på hjälten i spelet.</li>
            </ul>
            <h3>Avancerade features</h3>
            <p>Handjämförelser fungerar felfritt. Även om spelarna kommer till showdown med samma handklass så kan min applikation utläsa vilken hand som är starkast. Det fungerar så att först ar applikationen reda på vilka handklasser spelarna har. Om man redan efter detta kan utse en vinnare sker inga fler jämförelser. Om två spelare har samma vinnande handklass skickas deras händer vidare till en specifik handklass-jämförelse. Jag har skrivit denna koden så att parametrarna som skickas till den sista jämförelsen är arrayer med värden och färger. Detta gör att jämförelsen sker på arrayer och inte Handobjekt. Detta gör att koden är lätt att testa och kan användas i andra implementationer där handobjekten ser annorlunda ut.
            </p>
            <p>Mitt flöde kan se aningen komplicerat ut men det finns en del fördelar med detta. Jag ville skriva koden så att när användaren har gjort sitt spel så sker en hel spelrunda tills det är användarens tur att spela igen. Min de utgår från att i poker är spelet positions-baserat. Sist att agera är spelaren på knappen och först att agera är spelaren till vänster om knappen. När spelare A har gjort sitt spel så kommer i tur och ordning alla spelare bakom spelare A att göra sina spel. Har Spelare A inte gjort sitt spel ännu kommer all spelare framför spelare A att göra sina spel. I min implementation utgår allt från användarens input. Applikationen utläser om användare gjort ett spel. Om inte initieras alla spelare framför att göra sina spel (dessa spelare är sorterade per position). Om applikation läser att spelaren gjort ett spel så initieras alla spelare bakom att göra sina spel. Här skulle man kunna nöja sig men jag ha gjort logik för att nu bör applikationen förstå om bettingrundan är över. Om så inte är fallet bör vi återigen initiera alla spelare framför användaren att göra sina spel. Förutsatt att användare är kvar i handen är det alltid användarens tur att spela när flödet når templaten. Är användaren inte kvar i templen spelar datorspelarna mot varandra och användaren kan titta på allt som händer.
            </p>
            <p>Bet och statushantering. Mina spelar-klasser har generella nedskalade metoder för bet, syn, fold och raise. Dessa klasser skulle med enkelhet kunna användas i ett annat spel. Logiken för hur applikationen vet när det är dags att stänga bettingrundan och dela nästa gata är relativt simpelt om spelet har två spelare. Om Spelare A synar är bettingrundan över. Likaså om han eller hon foldar. När vi introducerar en till spelare är detta inte längre fallet. Spelare A kan nu syna en bet från spelare B medans spelare C ännu inte har agerat. Det räcker inte att göra en koll på om spelaren på knappen har synat. I exemplet ovan kan Spelare C bettat från lilla mörken och Spelare B raisat från stora mörken, Spelare A synar på knappen och nu måste turen återigen gå till Spelare C trots att spelaren i sista position synat. Då tänker du kanske att man kan enkelt använda priset som indikator istället. Om alla aktiva spelare har samma antal marker på bordet borde det betyda att vi kan dela nästa gata? Fel, Det finns många exempel på när detta inte är sant. Till exempel om en spelare synar in från en mörk men den största marken har inte fått agera ännu. I detta fallet är spelaren som synade senaste aktion ”syn” och priset att spelar är noll. Tots det ska vi inte del nästa gata här. Det har tagit mycket tid att jobba med detta och det blev en del små ”quick-fixes” i slutet för att hantera väldigt specifika fall för preflop. Som sagt har jag behövt kompromissa för att överhuvdtaget få in min inlämning då det finns så mycket att göra detta projektet. Jag kan dock stolt säga att kort- och bethantering fungerar som i ett tvättäkta pokerspel. Detta uppnår jag med genom att kombinera följande vetskaper. Priset att spela, vilken gata i spelet vi befinner oss i(”första gatan preflopp spelar annorlunda”), vilken spelares är sitter närmast knappen av de aktiva spelarna. Spelarnas senast registrerade aktion. Med hjälp av alla dessa parametrar och kunskap om hur poker-regler fungerar så har jag lyckats hantera alla märkliga situationer som kan uppstå och markerna och korten hanteras korrekt.
            </p>
            <h3>Övrigt</h3>
            <p>Som jag kort nämnde ovan så hade jag en del strul med att bygga detta projekt och det var extremt tidskrävande. I efterhand hade jag gärna valt ett mindre spel att implementera. Dels hade jag kunnat jobba med ORM i projektet men också bara för att träna på allt vi har lärt oss i ett mer hanterligt projekt. Jag kände många gånger att jag vill göra detta testdrivet men det är väldigt svårt när jag är osäker på hur min klass eller metod kommer att se ut i slutändan. När det är så mycket kod som ska skrivas och jag regelbundet gör stora ändringar på metoder eller klasser så känns det som att man inte har tid att varje gång enhets-testa först. Jag är nöjd med hur väl spelet fungerar men det hade nog varit mer tillfredsställande att göra ett mindre projekt som får högre betyg i phpmetrics och scrutinizer. Att få känna att man behärskar detta sättet att jobba på i ett mindre projekt innan man ger sig på ett större.
            </p>
            <p>Jag har lärt mig mycket bra grejer under kursen och kommer ha stor nytta av alla verktyg jag fått lära mig att använda. Det jobbiga med kursen har personligen varit extremt mycket krångel med nedladdningar och installationer. Det tillsammans med att både i kmom03 och projektet gjorde jag jättestora projekt har lett till att jag jobbat extremt hårt och trots det lämnar in sent. Jag är utmattad och ska äntligen börja på webapp-projektet. JJag har inte haft så mycket kontakt med lärarteam eller studenter under bortsett från felsökning av installationer. De gångerna har jag alltid fått bra hjälp. Jag ger kursen en 8. Jag är stolt över min insats och har försökt gör snygga inlämningar. Jag är överlag nöjd med handledningen, ska jag ge en liten kritik är det att under kmom03 var jag osäker på min användning av traits. Jag bad rättaren om feedback på mitt beslut men fick inget svar, jag fick känslan att rättaren inte hade läst min text.
            </p>
        </section>
        </aside>
    </div>
{% endblock %}
